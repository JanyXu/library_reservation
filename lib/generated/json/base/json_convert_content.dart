// ignore_for_file: non_constant_identifier_names// ignore_for_file: camel_case_types// ignore_for_file: prefer_single_quotes// This file is automatically generated. DO NOT EDIT, all your changes would be lost.import 'package:library_reservation/core/model/dic_data_value_entity.dart';import 'package:library_reservation/generated/json/dic_data_value_entity_helper.dart';import 'package:library_reservation/core/model/update_entity.dart';import 'package:library_reservation/generated/json/update_entity_helper.dart';import 'package:library_reservation/core/model/scan_result_entity.dart';import 'package:library_reservation/generated/json/scan_result_entity_helper.dart';import 'package:library_reservation/core/model/token_entity.dart';import 'package:library_reservation/generated/json/token_entity_helper.dart';import 'package:library_reservation/core/model/update_back_entity.dart';import 'package:library_reservation/generated/json/update_back_entity_helper.dart';import 'package:library_reservation/core/model/dic_data_entity.dart';import 'package:library_reservation/generated/json/dic_data_entity_helper.dart';class JsonConvert<T> {	T fromJson(Map<String, dynamic> json) {		return _getFromJson<T>(runtimeType, this, json);	}  Map<String, dynamic> toJson() {		return _getToJson<T>(runtimeType, this);  }  static _getFromJson<T>(Type type, data, json) {    switch (type) {			case DicDataValueEntity:				return dicDataValueEntityFromJson(data as DicDataValueEntity, json) as T;			case DicDataValueScanCodeResult:				return dicDataValueScanCodeResultFromJson(data as DicDataValueScanCodeResult, json) as T;			case DicDataValueScanCodeResultCqqrcode:				return dicDataValueScanCodeResultCqqrcodeFromJson(data as DicDataValueScanCodeResultCqqrcode, json) as T;			case UpdateEntity:				return updateEntityFromJson(data as UpdateEntity, json) as T;			case UpdateVersion:				return updateVersionFromJson(data as UpdateVersion, json) as T;			case ScanResultEntity:				return scanResultEntityFromJson(data as ScanResultEntity, json) as T;			case TokenEntity:				return tokenEntityFromJson(data as TokenEntity, json) as T;			case UpdateBackEntity:				return updateBackEntityFromJson(data as UpdateBackEntity, json) as T;			case DicDataEntity:				return dicDataEntityFromJson(data as DicDataEntity, json) as T;    }    return data as T;  }  static _getToJson<T>(Type type, data) {		switch (type) {			case DicDataValueEntity:				return dicDataValueEntityToJson(data as DicDataValueEntity);			case DicDataValueScanCodeResult:				return dicDataValueScanCodeResultToJson(data as DicDataValueScanCodeResult);			case DicDataValueScanCodeResultCqqrcode:				return dicDataValueScanCodeResultCqqrcodeToJson(data as DicDataValueScanCodeResultCqqrcode);			case UpdateEntity:				return updateEntityToJson(data as UpdateEntity);			case UpdateVersion:				return updateVersionToJson(data as UpdateVersion);			case ScanResultEntity:				return scanResultEntityToJson(data as ScanResultEntity);			case TokenEntity:				return tokenEntityToJson(data as TokenEntity);			case UpdateBackEntity:				return updateBackEntityToJson(data as UpdateBackEntity);			case DicDataEntity:				return dicDataEntityToJson(data as DicDataEntity);			}			return data as T;		}  //Go back to a single instance by type	static _fromJsonSingle<M>( json) {		String type = M.toString();		if(type == (DicDataValueEntity).toString()){			return DicDataValueEntity().fromJson(json);		}	else if(type == (DicDataValueScanCodeResult).toString()){			return DicDataValueScanCodeResult().fromJson(json);		}	else if(type == (DicDataValueScanCodeResultCqqrcode).toString()){			return DicDataValueScanCodeResultCqqrcode().fromJson(json);		}	else if(type == (UpdateEntity).toString()){			return UpdateEntity().fromJson(json);		}	else if(type == (UpdateVersion).toString()){			return UpdateVersion().fromJson(json);		}	else if(type == (ScanResultEntity).toString()){			return ScanResultEntity().fromJson(json);		}	else if(type == (TokenEntity).toString()){			return TokenEntity().fromJson(json);		}	else if(type == (UpdateBackEntity).toString()){			return UpdateBackEntity().fromJson(json);		}	else if(type == (DicDataEntity).toString()){			return DicDataEntity().fromJson(json);		}			return null;	}  //list is returned by type	static M _getListChildType<M>(List data) {		if(<DicDataValueEntity>[] is M){			return data.map<DicDataValueEntity>((e) => DicDataValueEntity().fromJson(e)).toList() as M;		}	else if(<DicDataValueScanCodeResult>[] is M){			return data.map<DicDataValueScanCodeResult>((e) => DicDataValueScanCodeResult().fromJson(e)).toList() as M;		}	else if(<DicDataValueScanCodeResultCqqrcode>[] is M){			return data.map<DicDataValueScanCodeResultCqqrcode>((e) => DicDataValueScanCodeResultCqqrcode().fromJson(e)).toList() as M;		}	else if(<UpdateEntity>[] is M){			return data.map<UpdateEntity>((e) => UpdateEntity().fromJson(e)).toList() as M;		}	else if(<UpdateVersion>[] is M){			return data.map<UpdateVersion>((e) => UpdateVersion().fromJson(e)).toList() as M;		}	else if(<ScanResultEntity>[] is M){			return data.map<ScanResultEntity>((e) => ScanResultEntity().fromJson(e)).toList() as M;		}	else if(<TokenEntity>[] is M){			return data.map<TokenEntity>((e) => TokenEntity().fromJson(e)).toList() as M;		}	else if(<UpdateBackEntity>[] is M){			return data.map<UpdateBackEntity>((e) => UpdateBackEntity().fromJson(e)).toList() as M;		}	else if(<DicDataEntity>[] is M){			return data.map<DicDataEntity>((e) => DicDataEntity().fromJson(e)).toList() as M;		}		throw Exception("not fond");	}  static M fromJsonAsT<M>(json) {    if (json is List) {      return _getListChildType<M>(json);    } else {      return _fromJsonSingle<M>(json) as M;    }  }}