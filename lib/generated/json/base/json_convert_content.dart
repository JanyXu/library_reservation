// ignore_for_file: non_constant_identifier_names// ignore_for_file: camel_case_types// ignore_for_file: prefer_single_quotes// This file is automatically generated. DO NOT EDIT, all your changes would be lost.import 'package:library_reservation/core/model/dic_data_entity.dart';import 'package:library_reservation/core/model/token_entity.dart';import 'package:library_reservation/generated/json/dic_data_entity_helper.dart';import 'package:library_reservation/core/model/scan_result_entity.dart';import 'package:library_reservation/generated/json/scan_result_entity_helper.dart';import 'package:library_reservation/core/model/dic_data_value_entity.dart';import 'package:library_reservation/generated/json/dic_data_value_entity_helper.dart';class JsonConvert<T> {	T fromJson(Map<String, dynamic> json) {		return _getFromJson<T>(runtimeType, this, json);	}  Map<String, dynamic> toJson() {		return _getToJson<T>(runtimeType, this);  }  static _getFromJson<T>(Type type, data, json) {    switch (type) {			case DicDataEntity:				return dicDataEntityFromJson(data as DicDataEntity, json) as T;			case ScanResultEntity:				return scanResultEntityFromJson(data as ScanResultEntity, json) as T;			case DicDataValueEntity:				return dicDataValueEntityFromJson(data as DicDataValueEntity, json) as T;			case TokenEntity:				return dicTokenResultFromJson(data as TokenEntity, json) as T;			case DicDataValueScanCodeResult:				return dicDataValueScanCodeResultFromJson(data as DicDataValueScanCodeResult, json) as T;			case DicDataValueScanCodeResultCqqrcode:				return dicDataValueScanCodeResultCqqrcodeFromJson(data as DicDataValueScanCodeResultCqqrcode, json) as T;    }    return data as T;  }  static _getToJson<T>(Type type, data) {		switch (type) {			case DicDataEntity:				return dicDataEntityToJson(data as DicDataEntity);			case ScanResultEntity:				return scanResultEntityToJson(data as ScanResultEntity);			case DicDataValueEntity:				return dicDataValueEntityToJson(data as DicDataValueEntity);			case DicDataValueScanCodeResult:				return dicDataValueScanCodeResultToJson(data as DicDataValueScanCodeResult);			case DicDataValueScanCodeResultCqqrcode:				return dicDataValueScanCodeResultCqqrcodeToJson(data as DicDataValueScanCodeResultCqqrcode);			}			return data as T;		}  //Go back to a single instance by type	static _fromJsonSingle<M>( json) {		String type = M.toString();		if(type == (DicDataEntity).toString()){			return DicDataEntity().fromJson(json);		}	else if(type == (ScanResultEntity).toString()){			return ScanResultEntity().fromJson(json);		}	else if(type == (DicDataValueEntity).toString()){			return DicDataValueEntity().fromJson(json);		}	else if(type == (DicDataValueScanCodeResult).toString()){			return DicDataValueScanCodeResult().fromJson(json);		}	else if(type == (DicDataValueScanCodeResultCqqrcode).toString()){			return DicDataValueScanCodeResultCqqrcode().fromJson(json);		}			return null;	}  //list is returned by type	static M _getListChildType<M>(List data) {		if(<DicDataEntity>[] is M){			return data.map<DicDataEntity>((e) => DicDataEntity().fromJson(e)).toList() as M;		}	else if(<ScanResultEntity>[] is M){			return data.map<ScanResultEntity>((e) => ScanResultEntity().fromJson(e)).toList() as M;		}	else if(<DicDataValueEntity>[] is M){			return data.map<DicDataValueEntity>((e) => DicDataValueEntity().fromJson(e)).toList() as M;		}	else if(<DicDataValueScanCodeResult>[] is M){			return data.map<DicDataValueScanCodeResult>((e) => DicDataValueScanCodeResult().fromJson(e)).toList() as M;		}	else if(<DicDataValueScanCodeResultCqqrcode>[] is M){			return data.map<DicDataValueScanCodeResultCqqrcode>((e) => DicDataValueScanCodeResultCqqrcode().fromJson(e)).toList() as M;		}		throw Exception("not fond");	}  static M fromJsonAsT<M>(json) {    if (json is List) {      return _getListChildType<M>(json);    } else {      return _fromJsonSingle<M>(json) as M;    }  }}